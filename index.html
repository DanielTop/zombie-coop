<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie Massacre - Online Co-op</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }
        .player-stats {
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 18px;
            border-radius: 10px;
            color: white;
            border: 2px solid;
            min-width: 200px;
        }
        .stat-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 4px 0;
            font-size: 13px;
        }
        .bar-container {
            flex: 1;
            height: 14px;
            background: #222;
            border-radius: 7px;
            overflow: hidden;
        }
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0040, #ff4080);
            transition: width 0.15s;
        }
        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffaa00, #ffdd00);
            transition: width 0.15s;
        }
        #centerUI {
            text-align: center;
            color: #fff;
        }
        #wave-display {
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255,0,64,0.5);
        }
        #kills-display {
            font-size: 18px;
            color: #ff6666;
        }
        #waveAnnounce {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 64px;
            color: #ff0040;
            text-shadow: 0 0 30px #ff0040, 0 0 60px #ff0040;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 50;
        }
        #minimap {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 180px;
            height: 120px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #444;
            border-radius: 8px;
            z-index: 10;
        }

        /* Lobby styles */
        #lobby {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a20 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        #lobby h1 {
            font-size: 72px;
            color: #ff0040;
            text-shadow: 0 0 40px #ff0040, 0 0 80px #ff0040;
            margin-bottom: 10px;
            letter-spacing: 4px;
        }
        #lobby .subtitle {
            color: #666;
            font-size: 20px;
            margin-bottom: 50px;
        }
        .lobby-section {
            background: rgba(255,255,255,0.03);
            padding: 30px 40px;
            border-radius: 15px;
            margin: 15px;
            border: 1px solid #333;
        }
        .lobby-section h3 {
            color: #888;
            margin-bottom: 15px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #lobby input {
            background: #111;
            border: 2px solid #333;
            padding: 15px 25px;
            font-size: 20px;
            color: #fff;
            border-radius: 10px;
            width: 300px;
            font-family: inherit;
            text-align: center;
            transition: border-color 0.2s;
        }
        #lobby input:focus {
            outline: none;
            border-color: #ff0040;
        }
        .color-picker {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 400px;
        }
        .color-option {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            border: 4px solid transparent;
            position: relative;
        }
        .color-option:hover {
            transform: scale(1.15);
        }
        .color-option.selected {
            border-color: #fff;
            box-shadow: 0 0 25px currentColor;
        }
        .color-option.taken {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .color-option.taken::after {
            content: '‚úï';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
        }
        #joinBtn {
            background: linear-gradient(135deg, #ff0040, #ff4080);
            border: none;
            padding: 18px 60px;
            font-size: 22px;
            color: white;
            border-radius: 12px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            letter-spacing: 2px;
            transition: all 0.2s;
            margin-top: 30px;
        }
        #joinBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(255, 0, 64, 0.5);
        }
        #joinBtn:disabled {
            background: #333;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Waiting room */
        #waitingRoom {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }
        #waitingRoom h2 {
            color: #ff0040;
            font-size: 42px;
            margin-bottom: 30px;
        }
        .players-list {
            display: flex;
            gap: 30px;
            margin-bottom: 40px;
        }
        .player-card {
            background: rgba(255,255,255,0.05);
            padding: 25px 35px;
            border-radius: 15px;
            text-align: center;
            border: 3px solid;
        }
        .player-card .avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin-bottom: 15px;
        }
        .player-card .name {
            color: #fff;
            font-size: 18px;
        }
        #startGameBtn {
            background: linear-gradient(135deg, #00aa44, #00dd66);
            border: none;
            padding: 18px 50px;
            font-size: 22px;
            color: white;
            border-radius: 12px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
        }
        #startGameBtn:hover {
            box-shadow: 0 0 30px rgba(0, 255, 100, 0.4);
        }
        #waitingText {
            color: #666;
            font-size: 18px;
            margin-top: 20px;
        }
        #roomCode {
            color: #ffdd00;
            font-size: 28px;
            margin-bottom: 10px;
            letter-spacing: 4px;
        }

        /* Level up panel - compact, doesn't block game */
        #levelUpOverlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.92);
            border: 3px solid #ffdd00;
            border-radius: 15px;
            padding: 15px 20px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 100;
            box-shadow: 0 0 40px rgba(255, 221, 0, 0.4);
            animation: levelUpPulse 0.5s ease-out;
        }
        @keyframes levelUpPulse {
            0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        #levelUpOverlay h2 {
            color: #ffdd00;
            font-size: 22px;
            margin-bottom: 12px;
            text-shadow: 0 0 15px #ffaa00;
        }
        .powerup-choices {
            display: flex;
            gap: 12px;
        }
        .powerup-choice {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #3a3a5a;
            border-radius: 12px;
            padding: 12px 15px;
            width: 100px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
        }
        .powerup-choice:hover {
            border-color: #ffdd00;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 221, 0, 0.5);
        }
        .powerup-choice .icon { font-size: 28px; margin-bottom: 6px; }
        .powerup-choice .name { color: #fff; font-size: 11px; font-weight: bold; }
        .powerup-choice .desc { display: none; }

        /* Game over */
        #gameOver {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        #gameOver h1 {
            color: #ff0040;
            font-size: 80px;
            text-shadow: 0 0 40px #ff0040;
        }
        #gameOver .stats {
            color: #fff;
            font-size: 28px;
            margin: 40px 0;
            line-height: 1.8;
        }
        #restartBtn {
            background: linear-gradient(135deg, #ff0040, #ff4080);
            border: none;
            padding: 18px 50px;
            font-size: 22px;
            color: white;
            border-radius: 12px;
            cursor: pointer;
            font-family: inherit;
        }

        /* MOBILE CONTROLS */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            top: 0;
            pointer-events: none;
            z-index: 100;
        }
        .joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }
        .joystick-base {
            width: 140px;
            height: 140px;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            position: relative;
        }
        .joystick-knob {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }
        .aim-zone {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 160px;
            height: 160px;
            background: rgba(255,0,64,0.15);
            border: 3px solid rgba(255,0,64,0.4);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 50px;
        }
        .aim-zone::after {
            content: 'üéØ';
            opacity: 0.6;
        }
        #mobileWeapon {
            position: absolute;
            bottom: 200px;
            right: 30px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 16px;
            pointer-events: none;
        }

        /* Mobile lobby scrollable */
        @media (max-width: 800px), (max-height: 700px) {
            #lobby {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                padding: 20px;
                justify-content: flex-start;
                padding-top: 40px;
            }
            #lobby h1 {
                font-size: 36px;
                margin-bottom: 5px;
            }
            #lobby .subtitle {
                font-size: 14px;
                margin-bottom: 20px;
            }
            .lobby-section {
                padding: 20px;
                margin: 10px;
                width: 90%;
                max-width: 350px;
            }
            #lobby input {
                width: 100%;
                max-width: 250px;
                padding: 12px 15px;
                font-size: 16px;
            }
            .color-option {
                width: 45px;
                height: 45px;
            }
            #joinBtn {
                padding: 15px 40px;
                font-size: 18px;
            }
            .player-stats {
                min-width: 120px;
                padding: 8px 12px;
                font-size: 11px;
            }
            .stat-row {
                font-size: 11px;
                gap: 5px;
            }
            #wave-display {
                font-size: 20px;
            }
            #kills-display {
                font-size: 14px;
            }
            #minimap {
                width: 100px;
                height: 70px;
            }
            /* Show mobile controls */
            #mobileControls {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game"></canvas>
        <div id="ui" style="display:none">
            <div class="player-stats" id="myStats" style="border-color: #00ff88">
                <div class="stat-row">
                    <span id="myName" style="font-weight:bold">–ò–≥—Ä–æ–∫</span>
                    <span id="myLevel">LVL 1</span>
                </div>
                <div class="stat-row">
                    <span style="color:#ff4466">HP</span>
                    <div class="bar-container"><div class="health-fill" id="myHealth"></div></div>
                </div>
                <div class="stat-row">
                    <span style="color:#ffdd00">XP</span>
                    <div class="bar-container"><div class="xp-fill" id="myXP"></div></div>
                </div>
                <div class="stat-row" style="color:#888;font-size:11px" id="myWeapon">–ü–∏—Å—Ç–æ–ª–µ—Ç</div>
            </div>
            <div id="centerUI">
                <div id="wave-display">–í–û–õ–ù–ê 1</div>
                <div id="kills-display">–£–±–∏–π—Å—Ç–≤: 0</div>
            </div>
            <div id="otherPlayers"></div>
        </div>
        <canvas id="minimap"></canvas>
        <div id="waveAnnounce"></div>

        <!-- Mobile Controls -->
        <div id="mobileControls">
            <div class="joystick-container" id="joystickContainer">
                <div class="joystick-base">
                    <div class="joystick-knob" id="joystickKnob"></div>
                </div>
            </div>
            <div class="aim-zone" id="aimZone"></div>
            <div id="mobileWeapon">üî´ –ü–∏—Å—Ç–æ–ª–µ—Ç</div>
        </div>

        <!-- Lobby -->
        <div id="lobby">
            <h1>ZOMBIE MASSACRE</h1>
            <div class="subtitle">Online Co-op Shooter</div>

            <div class="lobby-section">
                <h3>–¢–≤–æ—ë –∏–º—è</h3>
                <input type="text" id="playerName" placeholder="–í–≤–µ–¥–∏ –∏–º—è..." maxlength="15">
            </div>

            <div class="lobby-section">
                <h3>–ö–æ–¥ –∫–æ–º–Ω–∞—Ç—ã</h3>
                <input type="text" id="roomInput" placeholder="–í–≤–µ–¥–∏ –∫–æ–¥ –∏–ª–∏ –æ—Å—Ç–∞–≤—å –ø—É—Å—Ç—ã–º" maxlength="10">
            </div>

            <div class="lobby-section">
                <h3>–í—ã–±–µ—Ä–∏ —Ü–≤–µ—Ç</h3>
                <div class="color-picker" id="colorPicker"></div>
            </div>

            <button id="joinBtn">–í–û–ô–¢–ò –í –ò–ì–†–£</button>
        </div>

        <!-- Waiting Room -->
        <div id="waitingRoom">
            <div id="roomCode">–ö–û–ú–ù–ê–¢–ê: ----</div>
            <h2>–û–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–≤...</h2>
            <div class="players-list" id="playersList"></div>
            <button id="startGameBtn">–ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button>
            <div id="waitingText">–ü–æ–¥–µ–ª–∏—Å—å –∫–æ–¥–æ–º –∫–æ–º–Ω–∞—Ç—ã —Å –¥—Ä—É–≥–æ–º!</div>
        </div>

        <!-- Level Up -->
        <div id="levelUpOverlay">
            <h2>–£–†–û–í–ï–ù–¨ <span id="newLevel">2</span>!</h2>
            <div class="powerup-choices" id="powerupChoices"></div>
        </div>

        <!-- Game Over -->
        <div id="gameOver">
            <h1>GAME OVER</h1>
            <div class="stats" id="finalStats"></div>
            <button id="restartBtn">–í –õ–û–ë–ë–ò</button>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        // Responsive canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Socket connection
        const socket = io();

        // Game constants
        let MAP_WIDTH = 3000;
        let MAP_HEIGHT = 2000;

        // Weapons - 20 different weapons! BALANCED
        const WEAPONS = {
            // Tier 1 - Starting (waves 1-2) - NO PIERCE by default!
            pistol: { name: '–ü–∏—Å—Ç–æ–ª–µ—Ç', damage: 20, fireRate: 280, bulletSpeed: 20, spread: 0.03, bullets: 1, color: '#ffff00', icon: 'üî´', pierce: 0 },
            smg: { name: '–£–∑–∏', damage: 12, fireRate: 90, bulletSpeed: 22, spread: 0.12, bullets: 1, color: '#00ffff', icon: 'üî´', pierce: 0 },
            shotgun: { name: '–î—Ä–æ–±–æ–≤–∏–∫', damage: 18, fireRate: 500, bulletSpeed: 16, spread: 0.28, bullets: 6, color: '#ff8800', icon: 'üî´', pierce: 0 },

            // Tier 2 - Early (waves 3-4)
            doubleBarrel: { name: '–î–≤—É—Å—Ç–≤–æ–ª–∫–∞', damage: 22, fireRate: 700, bulletSpeed: 15, spread: 0.32, bullets: 10, color: '#ff6600', icon: 'üí•', pierce: 0 },
            rifle: { name: '–í–∏–Ω—Ç–æ–≤–∫–∞', damage: 50, fireRate: 350, bulletSpeed: 30, spread: 0.02, bullets: 1, color: '#ff00ff', pierce: 2, icon: 'üéØ' },
            minigun: { name: '–ú–∏–Ω–∏–≥–∞–Ω', damage: 10, fireRate: 60, bulletSpeed: 24, spread: 0.15, bullets: 1, color: '#ff4444', icon: 'üî•', pierce: 0 },
            flamethrower: { name: '–û–≥–Ω–µ–º—ë—Ç', damage: 8, fireRate: 40, bulletSpeed: 10, spread: 0.35, bullets: 3, color: '#ff4400', range: 180, icon: 'üî•', pierce: 0 },

            // Tier 3 - Mid (waves 5-7)
            sniper: { name: '–°–Ω–∞–π–ø–µ—Ä–∫–∞', damage: 150, fireRate: 1000, bulletSpeed: 50, spread: 0, bullets: 1, color: '#ff0088', pierce: 3, icon: 'üéØ' },
            laser: { name: '–õ–∞–∑–µ—Ä', damage: 35, fireRate: 100, bulletSpeed: 40, spread: 0, bullets: 1, color: '#00ff00', pierce: 5, icon: '‚ö°' },
            plasma: { name: '–ü–ª–∞–∑–º–∞', damage: 60, fireRate: 350, bulletSpeed: 14, spread: 0.06, bullets: 1, color: '#aa00ff', explosive: 55, icon: 'üíú', pierce: 0 },
            freezeGun: { name: '–ö—Ä–∏–æ-–ø—É—à–∫–∞', damage: 25, fireRate: 180, bulletSpeed: 18, spread: 0.08, bullets: 1, color: '#88ddff', freeze: true, icon: '‚ùÑÔ∏è', pierce: 0 },
            acidGun: { name: '–ö–∏—Å–ª–æ—Ç–∞', damage: 28, fireRate: 180, bulletSpeed: 16, spread: 0.12, bullets: 2, color: '#44ff44', poison: true, icon: '‚ò†Ô∏è', pierce: 0 },

            // Tier 4 - Late (waves 8-11)
            bazooka: { name: '–ë–∞–∑—É–∫–∞', damage: 120, fireRate: 900, bulletSpeed: 12, spread: 0.04, bullets: 1, color: '#ff2200', explosive: 100, icon: 'üöÄ', big: true, pierce: 0 },
            grenadeLauncher: { name: '–ì—Ä–∞–Ω–∞—Ç–æ–º—ë—Ç', damage: 80, fireRate: 600, bulletSpeed: 12, spread: 0.08, bullets: 1, color: '#44ff00', explosive: 85, icon: 'üí£', pierce: 0 },
            railgun: { name: '–†–µ–π–ª–≥–∞–Ω', damage: 200, fireRate: 1200, bulletSpeed: 60, spread: 0, bullets: 1, color: '#00ffff', pierce: 20, icon: '‚ö°', beam: true },
            chainLightning: { name: '–¢–µ—Å–ª–∞', damage: 40, fireRate: 350, bulletSpeed: 35, spread: 0, bullets: 1, color: '#ffff00', chain: 4, icon: '‚ö°', pierce: 0 },
            sawBlade: { name: '–ü–∏–ª–∞', damage: 30, fireRate: 300, bulletSpeed: 12, spread: 0, bullets: 1, color: '#cccccc', pierce: 10, boomerang: true, icon: '‚öôÔ∏è' },

            // Tier 5 - Epic (waves 12+)
            clusterBomb: { name: '–ö–∞—Å—Å–µ—Ç–∞', damage: 70, fireRate: 700, bulletSpeed: 14, spread: 0.08, bullets: 1, color: '#ffaa00', cluster: 6, icon: 'üí•', pierce: 0 },
            blackHole: { name: '–ß—ë—Ä–Ω–∞—è –¥—ã—Ä–∞', damage: 100, fireRate: 1800, bulletSpeed: 8, spread: 0, bullets: 1, color: '#8800ff', vortex: true, icon: 'üåÄ', big: true, pierce: 0 },
            nukeGun: { name: '–Ø–¥–µ—Ä–∫–∞', damage: 300, fireRate: 3000, bulletSpeed: 6, spread: 0, bullets: 1, color: '#ffff00', explosive: 200, nuke: true, icon: '‚ò¢Ô∏è', big: true, pierce: 0 },

            // NEW COOL WEAPONS
            crossbow: { name: '–ê—Ä–±–∞–ª–µ—Ç', damage: 80, fireRate: 800, bulletSpeed: 35, spread: 0, bullets: 1, color: '#8B4513', pierce: 5, icon: 'üèπ' },
            tripleShot: { name: '–¢—Ä—ë—Ö—Å—Ç–≤–æ–ª', damage: 25, fireRate: 400, bulletSpeed: 20, spread: 0.2, bullets: 3, color: '#ff6600', icon: 'üî´', pierce: 0 },
            bouncer: { name: '–†–∏–∫–æ—à–µ—Ç', damage: 40, fireRate: 500, bulletSpeed: 18, spread: 0.05, bullets: 1, color: '#00ff88', bounce: 5, icon: '‚öΩ', pierce: 0 },
            homing: { name: '–°–∞–º–æ–Ω–∞–≤–æ–¥', damage: 30, fireRate: 600, bulletSpeed: 12, spread: 0, bullets: 1, color: '#ff00aa', homing: true, icon: 'üéØ', pierce: 0 },
            shockwave: { name: '–®–æ–∫–≤–µ–π–≤', damage: 60, fireRate: 1200, bulletSpeed: 0, spread: 0, bullets: 1, color: '#ffffff', shockwave: 150, icon: 'üí´', pierce: 0 },
            gatling: { name: '–ì–∞—Ç–ª–∏–Ω–≥', damage: 5, fireRate: 25, bulletSpeed: 28, spread: 0.2, bullets: 2, color: '#888888', icon: 'üî•', pierce: 0 },
            deagle: { name: '–î–∏–≥–ª', damage: 70, fireRate: 450, bulletSpeed: 35, spread: 0.02, bullets: 1, color: '#C0C0C0', icon: 'üî´', pierce: 0 },
            firebomb: { name: '–ù–∞–ø–∞–ª–º', damage: 40, fireRate: 900, bulletSpeed: 10, spread: 0.1, bullets: 1, color: '#ff4400', explosive: 80, burn: true, icon: 'üî•', pierce: 0 },
            iceStorm: { name: '–õ–µ–¥—è–Ω–æ–π —à—Ç–æ—Ä–º', damage: 20, fireRate: 150, bulletSpeed: 16, spread: 0.3, bullets: 5, color: '#aaddff', freeze: true, icon: '‚ùÑÔ∏è', pierce: 0 }
        };

        // Powerups
        const POWERUPS = [
            { id: 'maxHp', icon: '‚ù§Ô∏è', name: '+25 –ú–∞–∫—Å. HP', desc: '–ë–æ–ª—å—à–µ –∑–¥–æ—Ä–æ–≤—å—è' },
            { id: 'damage', icon: '‚öîÔ∏è', name: '+15% –£—Ä–æ–Ω', desc: '–°–∏–ª—å–Ω–µ–µ —Å—Ç—Ä–µ–ª—å–±–∞' },
            { id: 'speed', icon: 'üëü', name: '+10% –°–∫–æ—Ä–æ—Å—Ç—å', desc: '–ë—ã—Å—Ç—Ä–µ–µ –±–µ–≥' },
            { id: 'fireRate', icon: 'üî•', name: '+20% –°–∫–æ—Ä–æ—Å—Ç—Ä–µ–ª—å–Ω–æ—Å—Ç—å', desc: '–ß–∞—â–µ —Å—Ç—Ä–µ–ª—å–±–∞' },
            { id: 'regen', icon: 'üíö', name: '–†–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è', desc: '–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ HP' },
            { id: 'armor', icon: 'üõ°Ô∏è', name: '+10% –ë—Ä–æ–Ω—è', desc: '–ú–µ–Ω—å—à–µ —É—Ä–æ–Ω–∞' },
            { id: 'xpBoost', icon: '‚≠ê', name: '+25% –û–ø—ã—Ç', desc: '–ë—ã—Å—Ç—Ä–µ–µ –ø—Ä–æ–∫–∞—á–∫–∞' },
            { id: 'critChance', icon: 'üí•', name: '+10% –ö—Ä–∏—Ç', desc: '–®–∞–Ω—Å —Ö2 —É—Ä–æ–Ω–∞' },
            { id: 'critDamage', icon: '‚ò†Ô∏è', name: '+50% –ö—Ä–∏—Ç —É—Ä–æ–Ω', desc: '–ú–æ—â–Ω–µ–µ –∫—Ä–∏—Ç—ã' },
            { id: 'pierce', icon: 'üéØ', name: '+1 –ü—Ä–æ–±–∏—Ç–∏–µ', desc: '–ü—É–ª–∏ –ø—Ä–æ–±–∏–≤–∞—é—Ç' },
            { id: 'magnet', icon: 'üß≤', name: '–ú–∞–≥–Ω–∏—Ç +50', desc: '–ü—Ä–∏—Ç—è–≥–∏–≤–∞–µ—Ç –ª—É—Ç' },
            { id: 'luck', icon: 'üçÄ', name: '+15% –£–¥–∞—á–∞', desc: '–ë–æ–ª—å—à–µ –¥—Ä–æ–ø–∞' },
            { id: 'bulletSize', icon: '‚ö´', name: '+20% –†–∞–∑–º–µ—Ä –ø—É–ª—å', desc: '–õ–µ–≥—á–µ –ø–æ–ø–∞–¥–∞—Ç—å' },
            { id: 'multishot', icon: 'üî´', name: '+1 –°–Ω–∞—Ä—è–¥', desc: '–î–æ–ø. –ø—É–ª—è' },
            { id: 'explosive', icon: 'üí£', name: '–í–∑—Ä—ã–≤–Ω—ã–µ –ø—É–ª–∏', desc: '10% —à–∞–Ω—Å –≤–∑—Ä—ã–≤–∞' },
            { id: 'vampire', icon: 'üßõ', name: '–í–∞–º–ø–∏—Ä–∏–∑–º +2', desc: 'HP –∑–∞ —É–±–∏–π—Å—Ç–≤–∞' },
        ];

        // Game state
        let myPlayer = null;
        let myId = null;
        let players = {};
        let zombies = [];
        let localBullets = [];
        let pickups = [];
        let particles = [];
        let floatingTexts = [];
        let camera = { x: 0, y: 0 };
        let mouseX = 0, mouseY = 0;
        let mouseDown = false;
        let lastShot = 0;
        let gameRunning = false;
        let selectedColor = null;
        let availableColors = [];
        let currentRoomId = null;

        // Local player stats (for quick response)
        let localStats = {
            x: 0, y: 0, angle: 0,
            hp: 100, maxHp: 100,
            level: 1, xp: 0, xpToLevel: 50,
            weaponKey: 'pistol',
            speed: 5,
            damageMultiplier: 1,
            fireRateMultiplier: 1,
            critChance: 0.05,
            critDamage: 1.5,
            pierce: 0,
            bulletSize: 1,
            bonusBullets: 0,
            explosiveChance: 0
        };

        let keys = {};

        // Mobile controls
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 800;
        let mobileJoystick = { active: false, dx: 0, dy: 0 };
        let mobileAim = { active: false, angle: 0 };
        let joystickTouchId = null;
        let aimTouchId = null;

        // Joystick touch handling
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickKnob = document.getElementById('joystickKnob');
        const aimZone = document.getElementById('aimZone');

        if (joystickContainer) {
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                joystickTouchId = touch.identifier;
                mobileJoystick.active = true;
                handleJoystickMove(touch);
            }, { passive: false });

            joystickContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let touch of e.changedTouches) {
                    if (touch.identifier === joystickTouchId) {
                        handleJoystickMove(touch);
                    }
                }
            }, { passive: false });

            joystickContainer.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === joystickTouchId) {
                        mobileJoystick.active = false;
                        mobileJoystick.dx = 0;
                        mobileJoystick.dy = 0;
                        joystickKnob.style.transform = 'translate(-50%, -50%)';
                        joystickTouchId = null;
                    }
                }
            });
        }

        function handleJoystickMove(touch) {
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const maxDist = 40;
            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }
            mobileJoystick.dx = dx / maxDist;
            mobileJoystick.dy = dy / maxDist;
            joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        }

        // Aim zone touch handling (auto-fire while touching)
        if (aimZone) {
            aimZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                aimTouchId = touch.identifier;
                mobileAim.active = true;
                handleAimMove(touch);
            }, { passive: false });

            aimZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let touch of e.changedTouches) {
                    if (touch.identifier === aimTouchId) {
                        handleAimMove(touch);
                    }
                }
            }, { passive: false });

            aimZone.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === aimTouchId) {
                        mobileAim.active = false;
                        aimTouchId = null;
                    }
                }
            });
        }

        function handleAimMove(touch) {
            const rect = aimZone.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = touch.clientX - centerX;
            const dy = touch.clientY - centerY;
            mobileAim.angle = Math.atan2(dy, dx);
        }

        // Update mobile weapon display
        function updateMobileWeapon() {
            const mobileWeaponEl = document.getElementById('mobileWeapon');
            if (mobileWeaponEl && WEAPONS[localStats.weaponKey]) {
                const w = WEAPONS[localStats.weaponKey];
                mobileWeaponEl.textContent = `${w.icon} ${w.name}`;
            }
        }

        // Setup color picker
        socket.on('colors', (colors) => {
            availableColors = colors;
            const picker = document.getElementById('colorPicker');
            picker.innerHTML = colors.map(c => `
                <div class="color-option" data-id="${c.id}" style="background: ${c.hex}" title="${c.name}"></div>
            `).join('');

            picker.querySelectorAll('.color-option').forEach(el => {
                el.addEventListener('click', () => {
                    if (el.classList.contains('taken')) return;
                    document.querySelectorAll('.color-option').forEach(e => e.classList.remove('selected'));
                    el.classList.add('selected');
                    selectedColor = el.dataset.id;
                });
            });

            // Auto-select first color
            const first = picker.querySelector('.color-option:not(.taken)');
            if (first) {
                first.classList.add('selected');
                selectedColor = first.dataset.id;
            }
        });

        socket.on('mapSize', ({ width, height }) => {
            MAP_WIDTH = width;
            MAP_HEIGHT = height;
        });

        // Join button
        document.getElementById('joinBtn').addEventListener('click', () => {
            const name = document.getElementById('playerName').value.trim() || '–ò–≥—Ä–æ–∫';
            let room = document.getElementById('roomInput').value.trim().toUpperCase();
            if (!room) {
                room = Math.random().toString(36).substring(2, 6).toUpperCase();
            }
            if (!selectedColor) {
                alert('–í—ã–±–µ—Ä–∏ —Ü–≤–µ—Ç!');
                return;
            }

            socket.emit('joinRoom', { roomId: room, playerName: name, colorId: selectedColor });
        });

        socket.on('error', (msg) => {
            alert(msg);
        });

        socket.on('joined', ({ playerId, player, roomId, players: roomPlayers }) => {
            myId = playerId;
            myPlayer = player;
            currentRoomId = roomId;

            localStats = { ...player };

            document.getElementById('lobby').style.display = 'none';
            document.getElementById('waitingRoom').style.display = 'flex';
            document.getElementById('roomCode').textContent = `–ö–û–ú–ù–ê–¢–ê: ${roomId}`;

            updatePlayersList(roomPlayers);

            const color = availableColors.find(c => c.id === player.colorId);
            document.getElementById('myStats').style.borderColor = color?.hex || '#fff';
            document.getElementById('myName').textContent = player.name;
            document.getElementById('myName').style.color = color?.hex;
        });

        socket.on('playerJoined', (player) => {
            players[player.id] = player;
            const allPlayers = [myPlayer, ...Object.values(players)];
            updatePlayersList(allPlayers);
        });

        socket.on('playerLeft', (playerId) => {
            delete players[playerId];
        });

        function updatePlayersList(playerList) {
            const container = document.getElementById('playersList');
            container.innerHTML = playerList.map(p => `
                <div class="player-card" style="border-color: ${p.color}">
                    <div class="avatar" style="background: ${p.color}"></div>
                    <div class="name">${p.name}</div>
                </div>
            `).join('');
        }

        // Start game
        document.getElementById('startGameBtn').addEventListener('click', () => {
            socket.emit('startGame');
        });

        socket.on('gameStarted', () => {
            document.getElementById('waitingRoom').style.display = 'none';
            document.getElementById('ui').style.display = 'flex';
            gameRunning = true;
            localBullets = [];
            particles = [];
            floatingTexts = [];
        });

        // Game state updates
        socket.on('state', (state) => {
            // Update other players
            state.players.forEach(p => {
                if (p.id === myId) {
                    // Update my stats from server (authoritative)
                    localStats.hp = p.hp;
                    localStats.maxHp = p.maxHp;
                    localStats.level = p.level;
                    localStats.alive = p.alive;
                    localStats.weaponKey = p.weapon;
                } else {
                    players[p.id] = p;
                }
            });

            zombies = state.zombies;
            pickups = state.pickups;

            document.getElementById('wave-display').textContent = `–í–û–õ–ù–ê ${state.wave}`;
            document.getElementById('kills-display').textContent = `–£–±–∏–π—Å—Ç–≤: ${state.kills}`;
        });

        socket.on('waveStart', (wave) => {
            showAnnouncement(`–í–û–õ–ù–ê ${wave}`);
        });

        socket.on('waveComplete', (wave) => {
            showAnnouncement('–í–û–õ–ù–ê –ü–†–û–ô–î–ï–ù–ê!');
        });

        socket.on('hit', ({ x, y, damage, crit }) => {
            floatingTexts.push({
                x, y: y - 20,
                text: Math.floor(damage).toString(),
                color: crit ? '#ff4400' : '#ffffff',
                life: 40,
                size: crit ? 22 : 16
            });

            for (let i = 0; i < 4; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 15,
                    color: '#ff4444',
                    size: 3
                });
            }
        });

        socket.on('zombieDied', ({ id, x, y, color }) => {
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * (2 + Math.random() * 4),
                    vy: Math.sin(angle) * (2 + Math.random() * 4),
                    life: 30 + Math.random() * 20,
                    color: color,
                    size: 4 + Math.random() * 5
                });
            }
        });

        socket.on('explosion', ({ x, y, radius, color, nuke }) => {
            createExplosion(x, y, radius, color, nuke);
        });

        function createExplosion(x, y, radius, color = '#ff4400', nuke = false) {
            const particleCount = nuke ? 100 : Math.floor(radius / 3);
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * (nuke ? 15 : 8);
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 30 + Math.random() * (nuke ? 60 : 30),
                    color: nuke ? ['#ffff00', '#ff8800', '#ff4400', '#ff0000'][Math.floor(Math.random()*4)] : color,
                    size: 3 + Math.random() * (nuke ? 10 : 6)
                });
            }
            // Shockwave effect
            if (nuke) {
                explosions.push({ x, y, radius: 0, maxRadius: radius * 1.5, life: 40, nuke: true });
            } else {
                explosions.push({ x, y, radius: 0, maxRadius: radius, life: 20 });
            }
        }

        let explosions = [];
        let otherPlayerBullets = []; // Bullets from other players

        // Receive bullets from other players
        socket.on('playerShot', ({ playerId, bullets }) => {
            bullets.forEach(b => {
                otherPlayerBullets.push({
                    ...b,
                    life: b.beam ? 20 : 50
                });
            });
        });

        socket.on('playerDied', (playerId) => {
            if (playerId === myId) {
                localStats.alive = false;
            }
        });

        socket.on('levelUp', (level) => {
            localStats.level = level;
            showLevelUp(level);
        });

        socket.on('pickup', (pickup) => {
            if (pickup.type === 'weapon') {
                localStats.weaponKey = pickup.weaponKey;
                socket.emit('changeWeapon', pickup.weaponKey);
                floatingTexts.push({
                    x: localStats.x, y: localStats.y - 40,
                    text: WEAPONS[pickup.weaponKey].name,
                    color: WEAPONS[pickup.weaponKey].color,
                    life: 60, size: 18
                });
            } else if (pickup.type === 'health') {
                floatingTexts.push({
                    x: localStats.x, y: localStats.y - 40,
                    text: '+25 HP',
                    color: '#ff4444',
                    life: 50, size: 16
                });
            } else if (pickup.type === 'xp') {
                floatingTexts.push({
                    x: localStats.x, y: localStats.y - 40,
                    text: '+XP',
                    color: '#ffdd00',
                    life: 40, size: 14
                });
            }
        });

        socket.on('gameOver', ({ wave, kills }) => {
            gameRunning = false;
            document.getElementById('gameOver').style.display = 'flex';
            document.getElementById('finalStats').innerHTML = `
                –í–æ–ª–Ω–∞: ${wave}<br>
                –í—Å–µ–≥–æ —É–±–∏–π—Å—Ç–≤: ${kills}<br>
                –¢–≤–æ–π —É—Ä–æ–≤–µ–Ω—å: ${localStats.level}
            `;
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            location.reload();
        });

        function showAnnouncement(text) {
            const el = document.getElementById('waveAnnounce');
            el.textContent = text;
            el.style.opacity = 1;
            setTimeout(() => { el.style.opacity = 0; }, 2500);
        }

        function showLevelUp(level) {
            document.getElementById('newLevel').textContent = level;
            const choices = document.getElementById('powerupChoices');
            const available = [...POWERUPS].sort(() => Math.random() - 0.5).slice(0, 4);

            choices.innerHTML = available.map((p, i) => `
                <div class="powerup-choice" data-id="${p.id}">
                    <div class="icon">${p.icon}</div>
                    <div class="name">${p.name}</div>
                    <div class="desc">${p.desc}</div>
                </div>
            `).join('');

            choices.querySelectorAll('.powerup-choice').forEach(el => {
                el.addEventListener('click', () => {
                    socket.emit('applyPowerup', el.dataset.id);

                    // Apply locally for immediate feedback
                    const p = POWERUPS.find(pw => pw.id === el.dataset.id);
                    switch(el.dataset.id) {
                        case 'damage': localStats.damageMultiplier *= 1.15; break;
                        case 'fireRate': localStats.fireRateMultiplier *= 0.8; break;
                        case 'critChance': localStats.critChance += 0.1; break;
                        case 'critDamage': localStats.critDamage += 0.5; break;
                        case 'pierce': localStats.pierce += 1; break;
                        case 'bulletSize': localStats.bulletSize *= 1.2; break;
                        case 'multishot': localStats.bonusBullets += 1; break;
                        case 'explosive': localStats.explosiveChance += 0.1; break;
                        case 'speed': localStats.speed *= 1.1; break;
                    }

                    floatingTexts.push({
                        x: localStats.x, y: localStats.y - 50,
                        text: p.name,
                        color: '#ffdd00',
                        life: 70, size: 18
                    });

                    document.getElementById('levelUpOverlay').style.display = 'none';
                });
            });

            document.getElementById('levelUpOverlay').style.display = 'flex';
        }

        // Input
        document.addEventListener('keydown', (e) => { keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) mouseDown = true;
        });
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) mouseDown = false;
        });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Game loop
        function update() {
            if (!gameRunning || !localStats.alive) return;

            // Movement - keyboard OR mobile joystick
            let dx = 0, dy = 0;
            if (keys['KeyW'] || keys['ArrowUp']) dy -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) dy += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) dx -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) dx += 1;

            // Mobile joystick input
            if (mobileJoystick.active) {
                dx = mobileJoystick.dx;
                dy = mobileJoystick.dy;
            }

            if (dx !== 0 || dy !== 0) {
                const len = Math.sqrt(dx*dx + dy*dy);
                if (len > 0) {
                    dx /= len; dy /= len;
                }
                localStats.x += dx * localStats.speed;
                localStats.y += dy * localStats.speed;
                localStats.x = Math.max(20, Math.min(MAP_WIDTH - 20, localStats.x));
                localStats.y = Math.max(20, Math.min(MAP_HEIGHT - 20, localStats.y));
            }

            // Aim - mouse OR mobile touch
            if (mobileAim.active) {
                // On mobile: aim using joystick angle on aim zone
                localStats.angle = mobileAim.angle;
            } else {
                // On desktop: aim at mouse (world coordinates)
                const worldMouseX = mouseX + camera.x;
                const worldMouseY = mouseY + camera.y;
                localStats.angle = Math.atan2(worldMouseY - localStats.y, worldMouseX - localStats.x);
            }

            // Send position to server
            socket.emit('move', { x: localStats.x, y: localStats.y, angle: localStats.angle });

            // Shooting - mouse OR mobile aim zone touch
            if (mouseDown || mobileAim.active) {
                shoot();
            }

            // Camera follow
            camera.x = localStats.x - canvas.width / 2;
            camera.y = localStats.y - canvas.height / 2;
            camera.x = Math.max(0, Math.min(MAP_WIDTH - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(MAP_HEIGHT - canvas.height, camera.y));

            // Update local bullets (visual + collision check)
            localBullets = localBullets.filter(b => {
                b.x += b.vx;
                b.y += b.vy;
                b.life--;

                // Visual collision with zombies (stop bullet on hit)
                if (!b.piercing) {
                    for (const z of zombies) {
                        const dist = Math.hypot(z.x - b.x, z.y - b.y);
                        if (dist < (z.radius || 20) + 5) {
                            // Hit! Create impact particles
                            for (let i = 0; i < 5; i++) {
                                particles.push({
                                    x: b.x, y: b.y,
                                    vx: (Math.random() - 0.5) * 8,
                                    vy: (Math.random() - 0.5) * 8,
                                    life: 12,
                                    color: b.color || '#ffff00',
                                    size: 3
                                });
                            }
                            return false; // Remove bullet
                        }
                    }
                }

                return b.life > 0 && b.x > -50 && b.x < MAP_WIDTH + 50 && b.y > -50 && b.y < MAP_HEIGHT + 50;
            });

            // Update other players' bullets (with collision)
            otherPlayerBullets = otherPlayerBullets.filter(b => {
                b.x += b.vx;
                b.y += b.vy;
                b.life--;

                // Visual collision with zombies
                for (const z of zombies) {
                    const dist = Math.hypot(z.x - b.x, z.y - b.y);
                    if (dist < (z.radius || 20) + 5) {
                        // Hit particles
                        for (let i = 0; i < 4; i++) {
                            particles.push({
                                x: b.x, y: b.y,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 10,
                                color: b.color || '#ffffff',
                                size: 2
                            });
                        }
                        return false;
                    }
                }

                return b.life > 0 && b.x > -50 && b.x < MAP_WIDTH + 50 && b.y > -50 && b.y < MAP_HEIGHT + 50;
            });

            // Update particles
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;
                return p.life > 0;
            });

            // Update floating texts
            floatingTexts = floatingTexts.filter(t => {
                t.y -= 1;
                t.life--;
                return t.life > 0;
            });
        }

        function shoot() {
            const now = Date.now();
            const weapon = WEAPONS[localStats.weaponKey];
            const fireRate = weapon.fireRate * localStats.fireRateMultiplier;

            if (now - lastShot < fireRate) return;
            lastShot = now;

            const totalBullets = weapon.bullets + localStats.bonusBullets;

            for (let i = 0; i < totalBullets; i++) {
                const spread = (Math.random() - 0.5) * weapon.spread * 2;
                const angle = localStats.angle + spread;
                const isCrit = Math.random() < localStats.critChance;
                const damage = weapon.damage * localStats.damageMultiplier * (isCrit ? localStats.critDamage : 1);

                const bulletData = {
                    x: localStats.x + Math.cos(localStats.angle) * 28,
                    y: localStats.y + Math.sin(localStats.angle) * 28,
                    vx: Math.cos(angle) * weapon.bulletSpeed,
                    vy: Math.sin(angle) * weapon.bulletSpeed,
                    damage,
                    color: weapon.color,
                    size: 5 * localStats.bulletSize,
                    pierce: (weapon.pierce || 0) + localStats.pierce,
                    crit: isCrit,
                    explosive: weapon.explosive || 0,
                    range: weapon.range || 1200,
                    // Special weapon properties
                    big: weapon.big,
                    beam: weapon.beam,
                    freeze: weapon.freeze,
                    chain: weapon.chain,
                    poison: weapon.poison,
                    boomerang: weapon.boomerang,
                    cluster: weapon.cluster,
                    vortex: weapon.vortex,
                    nuke: weapon.nuke
                };

                socket.emit('shoot', bulletData);

                // Local visual bullet (mark as piercing if has pierce > 0)
                localBullets.push({
                    ...bulletData,
                    life: weapon.beam ? 20 : 60,
                    piercing: (weapon.pierce || 0) + localStats.pierce > 0
                });
            }

            // Update mobile weapon display
            updateMobileWeapon();

            // Muzzle flash - bigger for explosive weapons
            const flashCount = weapon.big ? 15 : 6;
            const flashSize = weapon.big ? 8 : 4;
            for (let i = 0; i < flashCount; i++) {
                particles.push({
                    x: localStats.x + Math.cos(localStats.angle) * 28,
                    y: localStats.y + Math.sin(localStats.angle) * 28,
                    vx: Math.cos(localStats.angle + (Math.random()-0.5)) * (4 + Math.random()*(weapon.big ? 8 : 4)),
                    vy: Math.sin(localStats.angle + (Math.random()-0.5)) * (4 + Math.random()*(weapon.big ? 8 : 4)),
                    life: weapon.big ? 20 : 12,
                    color: weapon.color,
                    size: flashSize
                });
            }

            // Screen shake for big weapons
            if (weapon.big) {
                screenShake = 10;
            }
        }

        let screenShake = 0;

        function draw() {
            ctx.fillStyle = '#12121f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Screen shake
            let shakeX = 0, shakeY = 0;
            if (screenShake > 0) {
                shakeX = (Math.random() - 0.5) * screenShake * 2;
                shakeY = (Math.random() - 0.5) * screenShake * 2;
                screenShake *= 0.85;
                if (screenShake < 0.5) screenShake = 0;
            }

            ctx.save();
            ctx.translate(-camera.x + shakeX, -camera.y + shakeY);

            // Grid
            ctx.strokeStyle = '#1a1a2f';
            ctx.lineWidth = 1;
            const gridSize = 80;
            const startX = Math.floor(camera.x / gridSize) * gridSize;
            const startY = Math.floor(camera.y / gridSize) * gridSize;
            for (let x = startX; x < camera.x + canvas.width + gridSize; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, camera.y);
                ctx.lineTo(x, camera.y + canvas.height);
                ctx.stroke();
            }
            for (let y = startY; y < camera.y + canvas.height + gridSize; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(camera.x, y);
                ctx.lineTo(camera.x + canvas.width, y);
                ctx.stroke();
            }

            // Map border
            ctx.strokeStyle = '#ff004488';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, MAP_WIDTH, MAP_HEIGHT);

            // Pickups
            pickups.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                const pulse = 1 + Math.sin(Date.now() / 100) * 0.15;
                ctx.scale(pulse, pulse);

                if (p.type === 'weapon') {
                    ctx.shadowColor = WEAPONS[p.weaponKey]?.color || '#fff';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = WEAPONS[p.weaponKey]?.color || '#fff';
                    ctx.fillRect(-15, -6, 30, 12);
                    ctx.fillStyle = '#222';
                    ctx.fillRect(-12, -4, 24, 8);
                } else {
                    ctx.shadowColor = p.type === 'health' ? '#ff4444' : '#ffdd00';
                    ctx.shadowBlur = 12;
                    ctx.fillStyle = p.type === 'health' ? '#ff4444' : '#ffdd00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(p.type === 'health' ? '+' : '‚òÖ', 0, 1);
                }
                ctx.restore();
            });

            // Zombies - diverse types with unique looks
            zombies.forEach(z => {
                ctx.save();
                ctx.translate(z.x, z.y);
                ctx.globalAlpha = z.alpha || 1;

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath();
                ctx.ellipse(0, z.radius * 0.4, z.radius * 0.8, z.radius * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();

                // Different visuals based on icon type
                const icon = z.icon || 'zombie';

                if (icon === 'ghost') {
                    // Ghost - wavy transparent
                    ctx.fillStyle = z.color;
                    ctx.beginPath();
                    ctx.arc(0, -2, z.radius, 0, Math.PI * 2);
                    ctx.fill();
                    // Wavy bottom
                    ctx.beginPath();
                    ctx.moveTo(-z.radius, 0);
                    for (let i = 0; i <= 6; i++) {
                        const wx = -z.radius + (z.radius * 2 / 6) * i;
                        const wy = z.radius * 0.5 + Math.sin(Date.now() / 100 + i) * 4;
                        ctx.lineTo(wx, wy);
                    }
                    ctx.fill();
                } else if (icon === 'tank' || icon === 'giant' || icon === 'megaboss') {
                    // Tank/Giant - bulky square-ish
                    ctx.fillStyle = z.color;
                    ctx.fillRect(-z.radius * 0.9, -z.radius * 0.9, z.radius * 1.8, z.radius * 1.8);
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(-z.radius * 0.6, -z.radius * 0.6, z.radius * 1.2, z.radius * 1.2);
                } else if (icon === 'exploder') {
                    // Exploder - pulsing
                    const pulse = 1 + Math.sin(Date.now() / 80) * 0.15;
                    ctx.fillStyle = z.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, z.radius * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    // Warning glow
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, z.radius * pulse + 3, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (icon === 'runner' || icon === 'nightmare') {
                    // Fast - elongated
                    ctx.fillStyle = z.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, z.radius * 1.3, z.radius * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (icon === 'crawler') {
                    // Crawler - low to ground
                    ctx.fillStyle = z.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 2, z.radius * 1.1, z.radius * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (icon === 'spitter') {
                    // Spitter - with mouth
                    ctx.fillStyle = z.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, z.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#44ffaa';
                    ctx.beginPath();
                    ctx.arc(0, z.radius * 0.3, z.radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (icon === 'armored') {
                    // Armored - with shield
                    ctx.fillStyle = z.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, z.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#aaaaaa';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, z.radius + 2, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (icon === 'splitter') {
                    // Splitter - segmented
                    ctx.fillStyle = z.color;
                    ctx.beginPath();
                    ctx.arc(-z.radius * 0.3, 0, z.radius * 0.7, 0, Math.PI * 2);
                    ctx.arc(z.radius * 0.3, 0, z.radius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                } else if (icon === 'necro') {
                    // Necro - dark with skull
                    ctx.fillStyle = z.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, z.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${z.radius}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üíÄ', 0, 0);
                } else if (icon === 'boss') {
                    // Boss - crowned
                    ctx.fillStyle = z.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, z.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffdd00';
                    ctx.fillRect(-z.radius * 0.6, -z.radius - 8, z.radius * 1.2, 8);
                    // Crown spikes
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-z.radius * 0.4 + i * z.radius * 0.4, -z.radius - 8);
                        ctx.lineTo(-z.radius * 0.2 + i * z.radius * 0.4, -z.radius - 16);
                        ctx.lineTo(i * z.radius * 0.4, -z.radius - 8);
                        ctx.fill();
                    }
                } else {
                    // Normal zombie
                    ctx.fillStyle = z.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, z.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(0,0,0,0.35)';
                    ctx.beginPath();
                    ctx.arc(z.radius * 0.2, z.radius * 0.2, z.radius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Eyes for all except ghost
                if (icon !== 'ghost' && icon !== 'necro') {
                    ctx.fillStyle = icon === 'nightmare' ? '#ff00ff' : '#ff0000';
                    ctx.shadowColor = ctx.fillStyle;
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    const eyeSize = Math.max(2, z.radius * 0.2);
                    ctx.arc(-z.radius * 0.3, -z.radius * 0.15, eyeSize, 0, Math.PI * 2);
                    ctx.arc(z.radius * 0.3, -z.radius * 0.15, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Health bar
                if (z.hp < z.maxHp) {
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#222';
                    ctx.fillRect(-z.radius, -z.radius - 12, z.radius * 2, 6);
                    ctx.fillStyle = z.armor > 0 ? '#888888' : '#ff4444';
                    ctx.fillRect(-z.radius, -z.radius - 12, (z.hp / z.maxHp) * z.radius * 2, 6);
                }

                ctx.restore();
            });

            // Explosions (shockwaves)
            explosions.forEach(e => {
                e.radius += (e.maxRadius - e.radius) * 0.2;
                e.life--;
                ctx.globalAlpha = e.life / (e.nuke ? 40 : 20);
                ctx.strokeStyle = e.nuke ? '#ffff00' : '#ff4400';
                ctx.lineWidth = e.nuke ? 8 : 4;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
                ctx.stroke();
                if (e.nuke) {
                    ctx.fillStyle = `rgba(255, 200, 0, ${e.life / 80})`;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            explosions = explosions.filter(e => e.life > 0);
            ctx.globalAlpha = 1;

            // Other players' bullets
            otherPlayerBullets.forEach(b => {
                ctx.save();
                ctx.translate(b.x, b.y);
                ctx.rotate(Math.atan2(b.vy, b.vx));
                ctx.globalAlpha = Math.min(1, b.life / 20);
                ctx.shadowColor = b.color;
                ctx.shadowBlur = b.big ? 20 : 10;
                ctx.fillStyle = b.color;

                if (b.beam) {
                    ctx.fillRect(-40, -2, 80, 4);
                } else if (b.vortex) {
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(0, 0, b.size * 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = b.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, b.size * 2, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (b.big) {
                    ctx.beginPath();
                    ctx.ellipse(0, 0, b.size * 2.5, b.size * 1.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.ellipse(0, 0, b.size * 2, b.size * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // My bullets
            localBullets.forEach(b => {
                ctx.save();
                ctx.translate(b.x, b.y);
                ctx.rotate(Math.atan2(b.vy, b.vx));
                ctx.shadowColor = b.color;
                ctx.shadowBlur = b.big ? 25 : 12;
                ctx.fillStyle = b.color;

                if (b.beam) {
                    // Railgun beam
                    ctx.fillRect(-50, -2, 100, 4);
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(-60, -4, 120, 8);
                } else if (b.vortex) {
                    // Black hole
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.arc(0, 0, b.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = b.color;
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(0, 0, b.size * (2 + i), Date.now() / 100 + i, Date.now() / 100 + i + 2);
                        ctx.stroke();
                    }
                } else if (b.big) {
                    // Big projectiles (bazooka, nuke)
                    ctx.beginPath();
                    ctx.ellipse(0, 0, b.size * 3, b.size * 1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Trail
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = '#ff8800';
                    ctx.beginPath();
                    ctx.ellipse(-b.size * 2, 0, b.size * 2, b.size, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (b.freeze) {
                    // Ice projectile
                    ctx.fillStyle = '#88ddff';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = (i / 6) * Math.PI * 2;
                        const r = b.size * 1.5;
                        ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Normal bullet
                    ctx.beginPath();
                    ctx.ellipse(0, 0, b.size * 2.5, b.size, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            });

            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 50;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * (p.life / 40), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Other players
            Object.values(players).forEach(p => {
                if (!p.alive) return;
                drawPlayer(p.x, p.y, p.angle, p.color, p.name);
            });

            // My player
            if (localStats.alive) {
                drawPlayer(localStats.x, localStats.y, localStats.angle, myPlayer?.color || '#00ff88', myPlayer?.name || 'Me', true);
            }

            // Floating texts
            floatingTexts.forEach(t => {
                ctx.globalAlpha = t.life / 60;
                ctx.fillStyle = t.color;
                ctx.font = `bold ${t.size || 16}px Arial`;
                ctx.textAlign = 'center';
                ctx.shadowColor = t.color;
                ctx.shadowBlur = 8;
                ctx.fillText(t.text, t.x, t.y);
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            ctx.restore();

            // Crosshair
            ctx.strokeStyle = '#ffffff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(mouseX - 15, mouseY);
            ctx.lineTo(mouseX - 5, mouseY);
            ctx.moveTo(mouseX + 5, mouseY);
            ctx.lineTo(mouseX + 15, mouseY);
            ctx.moveTo(mouseX, mouseY - 15);
            ctx.lineTo(mouseX, mouseY - 5);
            ctx.moveTo(mouseX, mouseY + 5);
            ctx.lineTo(mouseX, mouseY + 15);
            ctx.stroke();

            // Update UI
            updateUI();

            // Draw minimap
            drawMinimap();
        }

        function drawPlayer(x, y, angle, color, name, isMe = false) {
            ctx.save();
            ctx.translate(x, y);

            // Glow
            ctx.shadowColor = color;
            ctx.shadowBlur = isMe ? 25 : 18;

            // Body
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();

            // Inner
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;

            // Gun
            ctx.rotate(angle);
            ctx.fillStyle = '#555';
            ctx.fillRect(12, -5, 22, 10);
            ctx.fillStyle = '#333';
            ctx.fillRect(12, -3, 18, 6);

            ctx.rotate(-angle);

            // Direction indicator
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(Math.cos(angle) * 14, Math.sin(angle) * 14, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // Name
            ctx.fillStyle = color;
            ctx.font = 'bold 13px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(name, x, y - 32);
        }

        function updateUI() {
            document.getElementById('myHealth').style.width = `${(localStats.hp / localStats.maxHp) * 100}%`;
            document.getElementById('myLevel').textContent = `LVL ${localStats.level}`;
            document.getElementById('myWeapon').textContent = WEAPONS[localStats.weaponKey]?.name || '–ü–∏—Å—Ç–æ–ª–µ—Ç';
        }

        function drawMinimap() {
            const mw = minimapCanvas.width;
            const mh = minimapCanvas.height;
            const scaleX = mw / MAP_WIDTH;
            const scaleY = mh / MAP_HEIGHT;

            minimapCtx.fillStyle = 'rgba(0,0,0,0.8)';
            minimapCtx.fillRect(0, 0, mw, mh);

            // View box
            minimapCtx.strokeStyle = '#ffffff44';
            minimapCtx.strokeRect(
                camera.x * scaleX,
                camera.y * scaleY,
                canvas.width * scaleX,
                canvas.height * scaleY
            );

            // Zombies
            minimapCtx.fillStyle = '#ff4444';
            zombies.forEach(z => {
                minimapCtx.beginPath();
                minimapCtx.arc(z.x * scaleX, z.y * scaleY, 2, 0, Math.PI * 2);
                minimapCtx.fill();
            });

            // Other players
            Object.values(players).forEach(p => {
                if (!p.alive) return;
                minimapCtx.fillStyle = p.color;
                minimapCtx.beginPath();
                minimapCtx.arc(p.x * scaleX, p.y * scaleY, 4, 0, Math.PI * 2);
                minimapCtx.fill();
            });

            // Me
            if (localStats.alive) {
                minimapCtx.fillStyle = myPlayer?.color || '#00ff88';
                minimapCtx.beginPath();
                minimapCtx.arc(localStats.x * scaleX, localStats.y * scaleY, 5, 0, Math.PI * 2);
                minimapCtx.fill();
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
